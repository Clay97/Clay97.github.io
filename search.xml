<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scrapy爬取boss直聘职位信息]]></title>
    <url>%2F2019%2F06%2F30%2Fscrapy%E7%88%AC%E5%8F%96boss%E7%9B%B4%E8%81%98%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[27号下午的时候朋友说软考可以查分了，于是我便怀着忐忑的心情去官网查了一下分，说实话当时还是比较紧张的，但是看到成绩时心里总是是松了一口气（甚至还有一些小激动），最终以54分和55分的成绩通过了软件设计师的考试，两个月的学习总算是没有白费。昨天又花了一下午的时间对boss直聘上有关爬虫的职位信息进行了爬取，使用的scrapy框架，项目在我的github上，大家可以参考或提出建议。 对item进行定义： 123456789101112131415161718192021class BosscrawlItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() #职位名称 position = scrapy.Field() # 薪水 salary = scrapy.Field() #公司地点 place = scrapy.Field() #需求 require = scrapy.Field() #学历要求 education = scrapy.Field() #公司名称 company = scrapy.Field() #公司类型 type = scrapy.Field() #融资阶段 stage = scrapy.Field() #公司规模 scale = scrapy.Field() 提取网页信息封装item对象 place、require 、education和type 、stage、scale 分别在图中圈住的位置，在html中在一个p标签中，可以通过如下代码进行提取：12place,require,education=info.xpath(&quot;//div[@class=&apos;info-primary&apos;]/p/text()&quot;).extract() type,stage,scale=info.xpath(&quot;//div[@class=&apos;company-text&apos;]/p/text()&quot;).extract() 但是在爬取过程中发现并非所有的p标签中都是3个字段 。 require字段由两部分组成 没有stage（融资阶段）字段 所以我们需要对字段的长度进行判断，完整代码如下：1234567891011121314151617181920212223def parse(self, response): #提取职位列表 jobs = response.xpath(&quot;//div[@class=&apos;job-primary&apos;]&quot;).extract() #遍历职位列表，提取信息 for job in jobs: positionitem = BosscrawlItem() info = scrapy.Selector(text=job) positionitem[&apos;position&apos;] =info.xpath(&quot;//div[@class=&apos;job-title&apos;]/text()&quot;).extract_first() positionitem[&apos;salary&apos;] = info.xpath(&quot;//span[@class=&apos;red&apos;]/text()&quot;).extract_first() info_primary = info.xpath(&quot;//div[@class=&apos;info-primary&apos;]/p/text()&quot;).extract() positionitem[&apos;place&apos;] = info_primary[0] positionitem[&apos;education&apos;] =info_primary[-1] positionitem[&apos;require&apos;] = info_primary[1] if len(info_primary)==4: positionitem[&apos;require&apos;]=info_primary[1]+&apos; &apos;+info_primary[2] positionitem[&apos;company&apos;] = info.xpath(&quot;//div[@class=&apos;company-text&apos;]/h3/a/text()&quot;).extract_first() info_company = info.xpath(&quot;//div[@class=&apos;company-text&apos;]/p/text()&quot;).extract() positionitem[&apos;type&apos;] = info_company[0] positionitem[&apos;scale&apos;] = info_company[-1] positionitem[&apos;stage&apos;]=&apos;&apos; if len(info_company)==3: positionitem[&apos;stage&apos;]=info_company[1] yield positionitem 提取跟进链接链接在最下面的翻页中href中：1urls =response.xpath(&quot;//div[@class=&apos;page&apos;]/a/@href&quot;).extract() 其中已经选中的页码的href为javascript:;,我们直接跳过，第一个a标签的href为上一页的链接，当你选中第一页时，他的page=0，但是他的内容返回内容是从和page=1的内容是一样的，所以我们遍历的时候从第二个元素开始遍历,之后拼接url并返回：12345for url in urls[1:]: if &apos;javascript&apos;in url: continue item = &apos;https://www.zhipin.com&apos;+url yield scrapy.Request(url=item,callback=self.parse) 数据存储在测试阶段，我将数据存储在本地的文件中，之后待测试完毕后存储在mongo数据库中，在pipelines.py中写了两个类BosscrawlPipeline,MongoPipeline分别用于将数据存储在本地和数据库中，使用的时候在settings中注释即可，这不是这次的重点，所以不做详细介绍。 其他扩展为了方便扩展，我将城市code和职位写在了settings中，然后在start_requests中进行遍历，具体的用法可以在github中查看： 123456def start_requests(self): for job in self.settings.get(&apos;QUERY&apos;): for code in self.settings.get(&apos;CITY_CODE&apos;): url =&apos;https://www.zhipin.com/c&apos;+code+&apos;/?query=&apos;+quote(job)+&apos;&amp;page=1&apos; print(url) yield scrapy.Request(url=url,callback=self.parse) 此外还可以添加随机的User-Agent的下载中间件，禁用cookies，设置下载延时和自动限速。至此，整个项目就完成了，希望对大家有所帮助。]]></content>
  </entry>
  <entry>
    <title><![CDATA[scrapyd部署爬虫遇到的问题]]></title>
    <url>%2F2019%2F06%2F14%2Fscrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用scrapyd部署查看job时出现以下错误： 刚开始的时候并没有太注意，后来在启动部署的爬虫是也出现这样的错误，然后便在网上查了一下并找到了解决方法：1.卸载原有的Twisted1pip uninstall Twisted 2.安装Twisted以前的版本直接通过pip install 安装会出现错误，所以大家可以使用.whl文件安装的方式安装。之后就可以用scrapyd部署自己的爬虫了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[分析Ajax爬取今日头条街拍美图]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%88%86%E6%9E%90Ajax%E7%88%AC%E5%8F%96%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E8%A1%97%E6%8B%8D%E7%BE%8E%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[大家好，我又回来了，在这消失的两个多月期间，一直在备战软考程序设计师，不管最终结果如何，我在这两个月期间学到了很多东西，而且还接触了python开始了自己的爬虫生涯。今天就和大家分享《Python 3网络爬虫开发实战》上关于爬取今日头条街拍美图的爬虫。由于书本是两年前发布的，网站的的Ajax发生了变化，但是分析起来也并没有想象的那么复杂，接下来我就大家一起来分析一下这个案列，代码已经上传到我的github欢迎大家参考并提出意见。首先，我们打开今日头条并在右上角的搜索入口输入街拍进行搜索。这时打开开发者工具，切换至Network，并选中XHR，接着下拉网页，便会出现很多请求，这就是我们需要分析的Ajax。 通过对比多个请求参数，我们可以其中变化的只有offset和timestamp，其中offset是偏移量，timestamp是毫秒级别的时间戳，可以通过int(time.time*1000)获得。接下来我们就构造请求来访问网页。 def get_page(offsetp): #offstep 作为参数传入 t = time.time() #时间戳 timestamp = int(t * 1000) params = { 'aid': 24, 'app_name': 'web_search', 'offset': offsetp, 'format': 'json', 'keyword': '街拍', 'autoload': 'true', 'count': 20, 'en_qc': 1, 'cur_tab': 1, 'from': 'search_tab', 'timestamp': timestamp } #请求头中Cookie是必须的，否则无法返回预期的json数据 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0', 'Cookie': 'tt_webid=6698224417073694219; UM_distinctid=16b1c89b4891dc-07c5eab40102ac-4c312d7d-100200-16b1c89b48a400; csrftoken=f2f895fa787b16b95088a70f7de231c9; __tasessionId=v9ffxsrfd1559551950358; CNZZDATA1259612802=1433961361-1559551484-https%253A%252F%252Flanding.toutiao.com%252F%7C1559551484; s_v_web_id=72ad7620bc7eee5c573a2fe6966db22e' } try: r = requests.get('https://www.toutiao.com/api/search/content/?', headers=headers, params=params) if r.status_code == 200: return r.json() except requests.ConnectionError : return None 偏移量offset作为参数传递，时间戳通过time方法生成，其中headers中Cookit参数是必不可少的，否则无法返回预期的json数据，最后通过requests进行请求，如果返回状态码200，则调用response的json()方法将结果转为json格式。接下来实现解析方法，保存图片链接，并和图片所属的标题一起返回，此时构造一个生成器。 def get_images(json): if json.get('data'): for item in json.get('data'): title = item.get('title') if (title == None): continue images = item.get('image_list') for image in images: yield { 'image': image.get('url'), 'title': title } 分析返回的json数据，发现所有图片的标题和链接都在data下，获取data并遍历，其中’title’字段保存了标题，其中标题为None的通常不是我们所需要的信息，直接跳过。最后通过’image_list’字段获取url列表，通过遍历构造生成器。接下来实现对图片的保存，在该方法中，首先根据item的title来创建文件夹，创建文件中出现异常直接返回，然后请求图片链接，获取图片二进制数据，以二进制形式写入文件。图片名称使用内容的md5值，达到去重目的。 def save_image(item): title = item.get('title') if not os.path.exists(title): try: os.mkdir(title) except Exception as e: print(e) return try: response = requests.get(item.get('image')) if response.status_code == 200: file_path = '{0}/{1}.{2}'.format(title,md5(response.content).hexdigest(),'jpg') if not os.path.exists(file_path): with open(file_path,'wb') as f: f.write(response.content) else: print('Aready Download',file_path) except requests.ConnectionError : print("Failed to save image") 最后，构造函数来遍历offset，提取图片链接，并下载： def main(offset): print(offset) json = get_page(offset) for item in get_images(json): print(item) save_image(item) time.sleep(1) if __name__ == "__main__": pool = Pool() pool.map(main, [i*20 for i in range(10)]) pool.close() pool.join() print("OK") 至此整个项目就完成了，最后我发现想爬取其他内容的图片，只需要将params中keyword的值修改即可，又兴趣的可以进行尝试，谢谢大家的阅读。]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓文件存储中遇到的问题]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在Android实训课上老师要求我们通过使用文件存储方式完成对qq密码的保存，并获取保存的文件中的qq账号密码。我写了下面的实现类来保存qq密码，并获取账号和密码。12345678910111213141516171819202122232425262728293031323334 public class FileSaveQQ &#123; //保存qq账号和密码data.txt文件中 public static boolean saveUserInfo(Context context,String number ,String password)&#123; try &#123; FileOutputStream fos =context.openFileOutput(&quot;data.txt&quot;,Context.MODE_PRIVATE); fos.write((number+&quot;:&quot;+password).getBytes()); fos.close(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; //从data.txt中获取存储的qq账号和密码 public static Map&lt;String,String&gt; getUserInfo(Context context)&#123; String content =&quot;&quot;; try &#123; FileInputStream fis=context.openFileInput(&quot;data.txt&quot;); byte[] buffer=new byte[fis.available()]; fis.read(buffer); content= new String(buffer); Map&lt;String,String&gt; userMap= new HashMap&lt;String,String&gt;(); String[] infos=content.split(&quot;:&quot;); userMap.put(&quot;number&quot;,infos[0]); userMap.put(&quot;password&quot;,infos[1]); fis.close(); return userMap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 当把整个逻辑代码写完运行到模拟器上时，后台报错 FileInputStream fis=context.openFileInput(“data.txt”) 找不到data.txt，于是我打开DDMS发现无法打开data下面的文件，于是百度寻找解决方法，发现data文件夹的读写权限只对用户组内的用户开放，对其他用户不开放，所以我们只需要把读写权限赋予其他用户即可，具体步骤如下所示：1.进入Android SDK安装目录，找到platform-tools点击进去，按shift键并点击鼠标右键选择在命令行打开2.输入adb shell 回车，然后再输入 su 回车进入权限root模式3.输入chmod -R 777 /data/ 回车即可。（-R 是对该目录下所有文件夹都执行此操作）这样我们就拥有对data下的文件的读写权限了，但是当我找到data.txt准备把他导出来查看里里面的信息时，发现这时候又报错了（难受），Failed to pull selection: open failed: Permission denied,意思是传输失败，没有权限，操作被拒绝。我们只需要在Android sdk目录下的platform-tools打开windows命令行执行adb root指令即可。到此问题都完美解决，我们就可以通过把data.txt文件导出来查看我们写入的内容了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android第一行代码 酷欧天气总结]]></title>
    <url>%2F2019%2F03%2F04%2FAndroid%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E9%85%B7%E6%AC%A7%E5%A4%A9%E6%B0%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[距离上次写博客大概已经过了半年了，期间一直在在学习《第一行代码》，前几天用了一周多了时间把最后的酷欧天气项目完成了，总体来说还是顺利的，中间遇到了一些困难，这里就在这里总结一下，希望对大家的学习有所帮助，代码在我的GitHub上酷欧天气，如果有需要大家可以下载参考，有什么错误也请大家能够指出来，我们一起学习。 1. 目录结构db:用于存放数据库模型相关的代码gson:用于存放GSON模型相关的代码service:用于存放服务相关的代码util:用于存放工具相关的代码 2. 创建数据库和表在创建数据库和表之前，在app/build.gradle中声明项目所需的各种依赖。OkHtttp用于进行网络请求，GSON用于解析JSON数据，Glide用于加载和展示图片。 这部分的内容比较简单，大家只需要按照书的内容一步一步来就可以了，首先创建Provincce,City,County这3个类并继承DataSupport，然后新建assets目录，创建 litepal.xml资源文件，用于创建数据库名称、数据库版本、表名、数据库存放的位置，最后再配置LitePalApplication。 3. 遍历全国省市县数据全国省市县的数据都需要从服务器端获取，因此首先在util包下创建一个HttpUtil类 public class HttpUtil { public static void sendOkHttpRequest(String address,okhttp3.Callback callback){ OkHttpClient client =new OkHttpClient(); Request request = new Request.Builder().url(address).build(); client.newCall(request).enqueue(callback); } } 这样我们只需要传入请求地址，并注册一个回调来处理服务器响应就可以了。由于服务器返回的都是JSON数据，创建Utility用于解析数据，注意调用save（）方法对数据进行保存，我第一次就是在这里栽了跟头，所以大家写代码的时候还是要细心一点。这部并没有什么难点，只需要照书上的代码就可以了。另外因为向服务器发起请求需要联网，所以必须在AndroidManifest.xml中进行网络的权限声明。 4. 显示天气信息这部分大概是最难的地方，当我按照书上代码解析数据时，总是闪退，后来通过搜索发现书上用的api已经过时了，所以解析不出来数据导致报错，于是我查找了官方文档，找到了相应的api，因为解析的数据有所不同，所以必须重新定义GSON实体类用于解析，相对与书本上的api，官方最新的实况天气的api相对简单，并没有预报和建议，于是我便添加了空气质量实况的api，定义了GSON实体类并解析数据，解析过程和书上的weather类似，大家可以参考我的代码。另外api中请求URL需要传入key值，这里的key是我们在注册完和风天气后在应用管理里面添加的key，在添加的时候key的类型要要选择成Web API 否则无法返回数据。在遍历空气质量实况中的数据时，通过inflater获取了view,然后在获取的组件的时候，我习惯性的直接用 findViewByid() 之后在向组件中添加信息的时候总是报空指针异常，后来经过反复检查才发现问题，获取控件的时候应该调用 view.findViewById(),写代码的时候不能随心所以，不可有一点马虎，否则就将造成打错。后面获取每日一图就相对容易一点，使用Glide就可以简单的解决。 5. 手动更新天气和切换城市这里首先运用了下拉刷新，下拉时重新请求服务器，数据解析完毕加载页面后关闭下拉刷新，隐藏进度条，整体的逻辑还是比较清楚的。切换城市运用了DrawerLayout,DrawerLayout中第一个子控件用于作为主屏幕中的内容，我们把SwipeRefreshLayout添加进去，第二个子控件作为滑动菜单显示的内容，只需要把第二个子控件的位置添加用于便利省市县数据的碎片。之后重写碎片中的代码就可以了。但是我发现当我手动选择完城市立即下拉刷新的时候，界面中显示的内容会变成刷新之前的城市的数据，通过对代码的观察，我发现下拉刷新调用的 requestWeather(mWeatherId) 中mWeatherId 并没有给他重新赋值，所以他还是原来城市的id，于是我在requestWeather(final String weatherid)方法中加入了 mWeatherId =weatherid; 因为选择县之后也会调用这个方法，这样我们就可以把新的县的id传入到这个全局变量中，从而使id变成选中之后的id。 6. 后台自动更新天气并修改图标和用户名称这部分内容包括更新天气和每日一图，只需要设置闹钟，重新解析数据并启动服务就可以了。至于修改图标和用户名就更简单不过了，相信大家一点也不会陌生。当然除了这些内容，还有很多内容可以去扩展，毕竟比起网上一些有关天气的app，我们的应用还是太过于简单。到这里我的总结也算是完成了，希望对大家有所帮助，也请大家提出宝贵的建议，毕竟我也是第一次写博客，还是个菜鸟很多的地方还是不懂，谢谢大家。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android常见控件]]></title>
    <url>%2F2018%2F07%2F01%2FAndroid%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文为大家分享了 8 种Android常见控件，主要针对控件的功能和属性对控件进行简单介绍，供大家参考，具体内容如下 1. TextViewTextView是 Android 程序开发中最常用的控件之一,主要功能是向用户展示文本的内容，它是不可编辑的 ,只能通过初始化设置或在程序中修改。12345&lt;TextView android:id="@+id/text_view" android:layout_width="match_parent" android:Layout_height="wrap_content" android:text="This is TextView"/&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content android:text 指定TextView中的文本显示内容 自定义 android:gravity 指定文字的对齐方式 top、bottom、left、right、center android:textSize 指定文字大小 自定义 android:textColor 指定文字颜色 RGB颜色 android:layout_width和android:Layout_heigh属性中match_parent和fill_parent的意义相同，推荐使用match_parent 表示让当前的控件的大小和父布局的大小一样，也就是由父布局来决定当前控件的大小，wrap_content表示让当前控件的大小能够刚好包含住里面的内容。android:gravity属性中可用 | 来指定多个值，center效果等同于 center_vertical | center_horizontal,表示文字在垂直和水平方向都居中对齐。 2. EditViewEditView是Android系统中的编辑框，可以理解为可编辑的TextView，用法和属性都和TextView相似。123456&lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:Layout_height="wrap_content" android:hint="Type something here" android:maxLines="2"/&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content android:hint 指定了一段提示文本 自定义 android:maxLine 指定了EditText最大行数 自定义 android:password 输入内容设置为password类型 true或者false android:phoneNumber 输入内容设置为phoneNumber类型 只能输入数字 android:hint指定了一段提示文本，当我们输入任何内容，这段文本就会自动消失。 3. ButtonButton控件也是使用过程中用的最多的控件之一，用户可以通过单击 Button 来触发一系列事件,然后为 Button 注册监听器,来实现 Button 的监听事件。123456&lt;Button android:id="@+id/button" android:layout_width="match_parent" android:Layout_height="wrap_content" android:text="Button" android:textAllCaps="false"/&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content android:text 指定按钮显示内容 自定义 在使用button时我们需要在Activity中为Button的点击事件注册一个监听器，在之后的文章中我们在进行介绍。 4. ImageButtonImageButton和Button类似，是一个按钮，ImageButton可以实现我们任何想要的图片按钮的效果。它要比button实现的要好看，并且体验要好很多, 不过它是以图片作为背景，没有文字。利用属性android:src=”图片位置”来设置图片背景。 123456&lt;ImageButtonandroid:id = "@+id/image_button"android:layout_width="match_parent" android:layout_height="wrap_content" android:scaleType="fitXY"android:src ="@drawable/***"&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content、像素 android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content、像素 android:src 指定图片来源 自定义 android:scaleType 指定图片在imagebutton中自适应方式 自定义 控件大小可以具体设置高度和宽度显示的像素，不过这样设置如果图片尺寸大于设置的显示的尺寸，则图片是显示不全的,可以配合scaleType，它的的属性有好几种，分别是matrix（默认）、center、centerCrop、centerInside、fitCenter、fitEnd、fitStart、fitXY。其中fitXY表示把原图按照指定的大小在View中显示，拉伸显示图片，不保持原比例，填满ImageView。对于其他属性我就不为大家进行一一介绍，感兴趣的可以自己了解一下。 5. RadioButton与RadioGroupRadioButton(单选按钮)在 Android 平台上也比较常用,比如一些选择项会用到单选按钮。它是一种单个圆形单选框双状态的按钮,可以选择或不选择。在 RadioButton 没有 被选中时,用户通过单击来选中它。但是,在选中后,无法通过单击取消选中。RadioGroup 是单选组合框,用于 将 RadioButton 框起来。在多个 RadioButton被 RadioGroup 包含的情况下,同一时刻只可以选择一个 RadioButton。1234567891011121314151617181920&lt;RadioGroup android:id="@+id/radio_group" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;RadioButton android:id="@+id/rd1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="北京" android:textSize="30sp" android:textColor="#FF0000" /&gt; &lt;RadioButton android:id="@+id/rd2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="30sp" android:text="上海" /&gt; &lt;/RadioGroup&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content android:orientation 指定按排列方式 水平排列horizontal或垂直排列vertical android:text 设置文字提示 自定义 android:textSize 指定文字大小 自定义 android:textColor 指定文字颜色 自定义 6. CheckBoxCheckBox(复选按钮),顾名思义是一种可以进行多选的按钮,默认以矩形表示。与 RadioButton 相同,它也有选中或者不选中双状态。1234567891011121314&lt;CheckBox android:id="@+id/cb1" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="北京" android:textSize="30sp" android:textColor="#0000FF"&lt;CheckBox android:id="@+id/cb2" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="上海" android:textSize="30sp" android:textColor="#0000FF"/&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content android:text 设置文字提示 自定义 android:textSize 指定文字大小 自定义 android:textColor 指定文字颜色 自定义 7. ImageViewImageView 是一个图片控件,负责显示图片，图片的来源可以是系统提供的资源文件,也可以是 Drawable 对象，它与前面我们讲过的ImageButton很多属性都是相同的。 123456&lt;ImageView=android:id = "@+id/xxx"android:layout_width="wrap_content"android:layout_height="wrap_content" android:scaleType="fitXY"android:src ="@drawable/***"&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content、像素 android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content、像素 android:src 指定图片来源 自定义 android:scaleType 指定图片在imagebutton中自适应方式 自定义 8. ProgressBarProgressBar 用于在界面上显示一个进度条,表示我们的程序正在加载一些数据，当程序运行后，会看到屏幕中有一个圆形进度条正在旋转。 123456&lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:Layout_height="wrap_content" style="?android:attr/progressBarStyleHorizontal" android:max="100"/&gt; 常用属性 说明 常用值 android:id 给当前控件指定唯一的标识符 自定义 android:layout_width 指定控件的宽度 match_parent、fill_parent、wrap_content、像素 android:Layout_heigh 指定控件的高度 match_parent、fill_parent、wrap_content、像素 style 设置进度条样式 默认为圆形、progressBarStyleHorizontal（水平进度条） android:max 设置进度条最大值 自定义 至此，关于Android的常用控件都已经大概介绍了一遍，希望能够对大家有所帮助。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
